%\VignetteEngine{knitr::knitr}

---
title: "RATs Tutorial"
author: "Kimon Froussios"
date: "15 July 2016"
output: 
  html_document: 
    fig_caption: yes
    keep_md: yes
    theme: readable
    toc: yes
runtime: shiny
---


# Relative Abundance of Transcripts (RATs).

This is an R package that builds on the functionality of [sleuth](http://pachterlab.github.io/sleuth/). It is 
aimed at people analyzing **gene expression** and **transcript abundance**, particularly with **RNA-Seq** type 
of data in mind.

It uses proportions test (based on chi-square) to find which transcripts of a gene change expression relative 
to the other transcripts of the same gene. For a more sensitive approach, it also uses G-test to find in which 
genes the transcripts change in abundance relative to one another, although that test is not able to tell which 
specific transcripts are responsible for this.

This *R Markdown* vignette constitutes the main documentation for the rats package.


## Example 1: Basic usage.

First, load the package (assuming it has been installed, as instructed in the README). [data.table](https://cran.r-project.org/web/packages/data.table/)
is optional, as most `data.frame` syntax should also work, but it is good measure to use the proper syntax. 
`data.table` should be available on your system anyway, since it is a crucial dependency for `rats`.

```{r}
library(rats)
library(data.table)
```


### Preparation of data

In a real usage case, the input data would be the output of [sleuth](http://pachterlab.github.io/sleuth/). 
For details on what that looks like and how to use sleuth you should refer to its proper documentation.

For this example, we'll use the **bundled data simulator**.


```{r}
simdat <- sim_sleuth_data(cnames = c("foo", "bar"))

# For convenience let's assign the contents of the list to separate variables.
slo <- simdat$slo       # Simulated minimal sleuth object.
annot <- simdat$annot  # Annotation for the above data.

```

The above function was created with code testing in mind, however the simulated data is convenient for 
demonstrating how the package works. The data is completely artificial and chosen so as to test/demonstrate 
specific scenarios. It contains a handful of made-up genes and transcripts, and a handful of samples/replicates
with a handful of bootstraps per sample. Real data will likely have many more bootstraps per sample, and 
*hopefully more replicates* per conditions as well.

The simultion returns a list of 3 objects, only the first two of which are relevant here:

1. `slo` emulates an R object you would obtain from calling **differential transcript expression (DTE)** using 
[sleuth](http://pachterlab.github.io/sleuth/). The real sleuth objects are quite large and complex nested lists. 
The simulated one contains only the bare minimum parts that are relevant to calling **differential transcript 
usage (DTU)** with `rats`.

```{r}
# Let's have a look at the simulated data.
summary(slo)
# Names of the samples and conditions.
print( slo$sample_to_covariates )
```

The values under `condition` are the ones we specified when we called the simulator. The simulator is coded 
to assign them to specific samples. There's also an additional variable, `batch`, which is added by the
simulator. Ignore it for now. *Your data may have more/fewer/different variables*. `rats` uses this table 
to group samples together for comparison.

```{r}
# Estimated fragment counts in bootstrap 1 of sample 1.
print( slo$kal[[1]]$bootstrap[[1]] )
```

`kal` is a list of samples (in this case there are 4). Each sample is a list that normally contains various 
tables and information. `rats` only uses the bootstrapped counts, so the simulated data only contains
the element `bootstrap`. This in turn is a list of tables, one per bootstrap iteration (in this case just 
2 or 3 iterations). Each table lists the estimated counts for each transcript id. The real data would also 
list TPMs.

2. `annot` is an auxiliary `data.frame` required by `rats`. It simply matches transcript identification codes 
to gene identification codes. **When working with your own data, you will need to provide an appropriate such 
dataframe**.

```{r}
# And this is what the annotation looks like.
print(annot)
```


### Calling DTU

With our simulated data at hand, we can now call DTU using rats:

```{r}
mydtu <- call_DTU(slo, annot, "foo", "bar")
```

`call_DTU()` takes 4 mandatory arguments: a sleuth object, an annotation dataframe matching transcripts to 
genes, and the names of two conditions to compare. By default, the two names are expected to be values found 
in the "condition" column of the `slo$sample_to_conditions` table. You can override this if the column is 
named differently in your data, or if you want to compare by a different variable. More on this in the 
example that deals with the input options.

The returned structure is a list with 3 elements:

```{r}
print( summary(mydtu) )
```

1. `Parameters` is a list that contains information about the data and the settings.

```{r}
# See the elements.
print( names(mydtu$Parameters) )

# See the value of one of the elements (ie. the P-value threshold).
print( mydtu$Parameters[["p_thresh"]] )
```

2. `Genes` is a [data.table](https://cran.r-project.org/web/packages/data.table/) that contains gene-level 
information. The results of the **G tests** are found here. A large number of columns are NA in this example, 
as they refer to bootstrapping, which is not carried out by default.

```{r}
# See the fields in the table.
print( names(mydtu$Genes) )

# See which genes have DTU.
print( mydtu$Genes[(Gt_DTU), parent_id] )
# NA are valid responses for genes that didn't meet some prerequisites:
print( mydtu$Genes[, .(parent_id, eligible, Gt_DTU)] )
```

3. `Transcripts` is a [data.table](https://cran.r-project.org/web/packages/data.table/) that contains 
transcript-level information. The results of the **proportion tests** are found here. Several columns are `NA` 
in this example, as they refer to bootstrapping, which is not carried out by default.

```{r}
# See the fields in the table.
print( names(mydtu$Transcripts) )

# See which Transcripts show relative change.
print( mydtu$Transcripts[(Pt_DTU), .(target_id, parent_id)] )

# Not all transcripts meet the prerequisites:
print( mydtu$Transcripts[, .(target_id, eligible, Pt_DTU)] )
```


### Results

1. The `Gt_DTU` column in the `Genes` table marks which **genes** show significant change in the proportions 
of their transcripts. It takes into account all the transcripts of the gene, which makes it more sensitive to 
changes but prevents it from attributing the change to specific transcripts in the gene. An expanded version 
of the column is copied intp the `Transcripts` table as well.
2. The `Pt_DTU` column in the `Transcripts` table marks the **transcripts** whose proportion changes 
significantly. It inspects each transcript in isolation, which makes it less sensitive. An aggregated version 
of the column is copied into the `Genes` table as well.
3. `parent_id` lists the gene IDs. `target_id` lists the transcript IDs.
4. Most other columns offer additional information to help understand the result. Refer to the next example 
for more details.

The `Pt_DTU` and `Gt_DTU` can differ from one another, as they are based on different tests and subject to 
different restrictions. They are complementary to one another. In our example, genes `CC` and `MIX6` show 
differential transcript usage. 


## Example 2: Output in detail.

As seen in the previous example, the output structure contains two large tables. This example will focus on 
explaining what all the fields are. 

We'll use the same simulated dataset as the previous example, but we'll add bootstrapping to the call of DTU, 
so we have information in all the output fields.

```{r}
library(data.table)
library(rats)

# Same data simulation as previous example.
sim <- simdat <- sim_sleuth_data(cnames = c("foo", "bar"))

# Calling and bootstrapping DTU.
mydtu <- call_DTU(sim$slo, sim$annot, "foo", "bar", boots = "both", bootnum = 10)
```

The two extra arguments in the function call specify that we want to bootstrap both the gene-level and 
transcript-level tests, and that we want 10 bootstrap iterations. More on bootstrapping when we address the 
input parameters in a following example.

### Parameters

`Parameters` is a list that contains information about the data and the settings.

```{r}
# Types of list's elements.
print( summary(mydtu$Parameters) )
```

1. `var_name` The name of the variable by whivh the samples were grouped. This is a column name in the `slo$sample_to_covariates` table.
2. `cond_A` and `cond_B` The names of the two groups of samples to compare. These are values of the above column.
3. `num_replic_A` and `num_replic_B` The number of samples in each group.
4. `p_thresh` The P-value threshold being used to call DTU.
5. `count_thresh` The minimum allowed fragment count per sample for each transcript.
6. `dprop_thresh` The minimum difference in proportion of a transcript that is considered biologically significant.
7. `tests` Which of the two test were carried out.
8. `bootstrap` Which of hte two tests were bootstrapped.
9. `bootnum` The number of bootstrap iterations.
10. `threads` How many threads were assigned. (Multithreading option not currently in use).

### Genes

`Genes` is a [data.table](https://cran.r-project.org/web/packages/data.table/) with many fields, listing 
information at the gene level.

```{r}
# Types of table's elements.
print( lapply(mydtu$Genes, typeof) )
```

1. `parent_id` The identification name/code of the gene.
2. `known_transc` The number of annotated transcripts for the gene.
3. `detect_transc` The number of transcripts with non-zero expression in at least one of the two conditions. 
`known_transc >= detect_transc`.
4. `elig_transc` Number of transcripts eligible for DTU calling. `detect_transc >= elig_transc`. See the 
`Transcripts` table info below for details on how these are determined.
5. `eligible` Whether the gene meets the pre-requisites: It needs at least 2 eligible transcripts for G test 
to be applicable and for DTU to make sense.
6. `Pt_DTU` Aggregated from `Transcript$Pt_DTU`. Signifies that at least one transcript has changed significantly 
according to the transcript-wise test.
Look up the gene in the `Transcripts` table to see which transcripts are resposible.
7. `Gt_DTU` The gene collectively shows DTU, according to the gene-wise test. It is not possible to attribute 
this to specific transcripts.
8. `Gt_dtuAB` and `Gt_dtuBA` Partial DTU calls. *The gene-wise test is G-test. This test compares counts to a 
theoretical set of expected proportions. As we have two sets of counts instead, and no
theoretical expectations, we do the test both ways, using in turn each condition as a reference. If **both** 
directions agree, then we call that gene DTU.* `Gt_DTU = Gt_dtuAB & Gt_dtuBA`.
9. `Gt_pvalAB` and `Gt_pvalBA` The raw P-values from the G tests.
10. `Gt_pvalAB_corr` and `Gt_pvalBA_corr` The above P-values adjusted for multiple testing (number of genes).
11. `Gt_boot_dtu` The fraction of bootstrap iterations in which the gene was called DTU. It can be used as a 
measure of confidence in the DTU call. Values closer to `1` indicate strong tendency for DTU, whereas values 
nearer `0` indicate lack of DTU. Values near `0.5` indicate lack of confidence either way and should be treated 
carefully.
12. `Gt_boot_meanAB` and `Gt_boot_meanBA` The partial mean P-value across the bootstraps.
13. `Gt_boot_stdevAB` and `Gt_boot_stdevBA` The partial standard deviation of the mean P-value across the bootstraps.
14. `Gt_boot_minAB` and `Gt_boot_minBA` The minimum (most significant) partial P-values that occurred in the bootstraps.
15. `Gt_boot_maxAB` and `Gt_boot_maxBA` The maximum (least significant) partial P-values that occurred in the bootstraps.
16. `Gt_boot_na` The fraction of bootstrap iterations in which the gene was not eligible for DTU calling.

### Transcripts

`Transcripts` is a [data.table](https://cran.r-project.org/web/packages/data.table/) with many fields, listing 
information at the transcript level.

```{r}
# Types of table's elements.
print( lapply(mydtu$Transcripts, typeof) )
```

1. `target_id` and `parent_id` The identification name/code of the transcript and gene, repsectively.
2. `propA` and `propB` The proportional abundance of the transcript in each of the two conditions.
3. `Dprop` The difference in proportional abundance of the transcript between the two conditions.
4. `eligible` Whether the transcript meets some pre-requisites: It requires proportion change greater than the 
threshold `abs(Dprop) > dprop_thresh` (see `Parameters` above) and a fragment count above
the threshold `meanA > count_thresh | meanB > count_thresh` (see below and `Parameters` above).
5. `Gt_DTU` Expanded from `Genes$Gt_DTU`. Indicates that the gene as a whole shows significant change in proportions 
of its transcripts.
6. `Pt_DTU` Whether the transcript's proportion changed significantly, according to the transcript-wise test. **It 
is perfectly possible to get `FALSE` or `NA` in this field despite `Gt_DTU` being `TRUE`**.
7. `Pt_pval` The raw P-value for the transcript.
8. `Pt_pval_corr` The above P-value adjusted for multiple testing (number of transcripts).
9. `Pt_boot_dtu` The fraction of bootstrap iterations in which the transcript was called DTU. It can be used as 
a measure of confidence in the DTU call. Values closer to `1` indicate strong tendency for DTU, whereas values 
nearer `0` indicate lack of DTU. Values near `0.5` indicate lack of confidence either way and should be treated 
carefully.
10. `Pt_boot_mean` The mean P-value across the bootstraps.
11. `Pt_boot_stdev` The the standard deviation of the mean P-value across the bootstraps.
12. `Pt_boot_min` The minimum (most significant) P-value that occurred in the bootstraps.
13. `Pt_boot_max` The maximum (most significant) P-value that occurred in the bootstraps.
14. `Pt_boot_na` The fraction of bootstrap iterations in which the transcripts was not eligible for DTU calling.
15. `sumA` and `sumB` The sum of counts across samples for each condition. This is used for the tests, so that a 
higher number of samples leads to higher significance.
16. `meanA` and `meanB` The mean of counts across samples for each condition.
17. `stdevA` and `stdevB` The standard deviation of the mean counts across samples for each condition.
18. `totalA` and `totalB` The total counts for the gene, ie `totalA == sum(sumA)`.

### Results pt.2

Now that you know what all the fields are, let's revisit the output of the DTU call and look into some details of 
its behaviour and how to interpret the information.

```{r}
# Let's check the info and settings.
print( mydtu$Parameters )
```

* We're comparing samples by `r mydtu$Parameters[["var_name"]]`, and the two values of that are `r mydtu$Parameters[["cond_A"]]` 
(with `r mydtu$Parameters[["num_replic_A"]]` samples) and `r mydtu$Parameters[["cond_B"]]` (with `r mydtu$Parameters[["num_replic_B"]]` 
samples). 
* The significance threshold is set to `r mydtu$Parameters[["p_thresh"]]`, the minimum count per sample is set to 
`r mydtu$Parameters[["count_thresh"]]` fragments and the proportion has to change by at least `r mydtu$Parameters[["dprop_thresh"]]` 
to be considered biologically significant.
* Are we doing gene-level or transcript-level tests? `r mydtu$Parameters[["tests"]]`
* Are we bootstrapping the gene-level or transcript-level tests? `r mydtu$Parameters[["bootstrap"]]`. And we're 
doing `r mydtu$Parameters[["bootnum"]]` iterations (unless "none").
* The multi-threading capability is not currently implemented, but if it was, it would be using `r mydtu$Parameters[["threads"]]` threads.


```{r}
# Gene-level calls.
print( mydtu$Genes )
```

There are `r dim(mydtu$Genes)[1]` genes in the annotation used.

* `1A1N` has only one known transcript and is thus not eligible. If you look in `slo$kal[[1]]$bootstraps[[1]]`, there 
are actually two recorded transcripts for this gene, but only one of them is recorded in the annotation. `rats` Uses 
the annotation as the basis for managing information. Any transcripts/genes present in the sleuth data but missing from 
the annotation, will be ignored completely.
* `1B1C` has two annotated transcripts, but only one of them is recorded in our data, so it is not eligible either. This
can happen if different annotation versions are used for `sleuth` and `rats`.
* `1D1C` has two transcripts, but only one was detected in our data, so it too is not eligible. Both transcript are 
present in the sleuth data, but one of them is zero in both conditions.
* `CC` has two known transcripts, both of which are detected and eligible, therefore it is eligible for DTU. It is 
called as DTU on both the transcript and gene levels, with very high significances. It was called as DTU in all the 
bootstrap iterations, giving us confidence in the result.
* `LC` has two known transcripts, both of which are detected but only one of them is eligible, so it is not eligible for 
testing at the gene level.
* `MIX6` has six transcripts, 5 of which are detected, only 3 of which are eligible. The gene is called as DTU with 
extremely high significance.
* `NIB`  has a single transcript that is not detected. Looking into `slo$kal[[1]]$bootstraps[[1]]` it is evident that 
the entire gene is not recorded in the data. As with `1B1C`, this can happen when different annotation versions are 
used between `sleuth` and `rats`.
* `NN` has two transcripts, both of which are detected, but neither of which is eligible, so the gene also is not eligible.

```{r}
# Transcript-level calls.
print( mydtu$Transcripts )
```

We'll focus on some of the genes with interesting things going on.

* `CC_a` and `CC_b` both show a change in proportion (`Dprop`) above the threshold (`Parameters$p_thresh`), as well as 
counts (`sumA` and `sumB` above the threshold (`Parameters$counts_thresh`) so they are eligible. They are positive for 
DTU at both the gene and transcript level. The significance is in the order 0.02 for both and they were called as DTU 
in all the bootsrtap iterations.
* `LC1` and `LC2` both change in proportion above the threshold, but `LC1` does not meet the counts threshold with an 
average < 5. `LC2` is eligible for transcript-wise testing and comes out as non-DTU. None of the boostraps found it DTU, 
but in half of them it was not eligible for testing (probably due to failing the counts threshold). Gene-level DTU cannot 
be called since `LC1` is not eligible.
* `MIX.c1`, `MIX.c2` and `MIX.c4` all show significant individual change. `MIX.c3` and `MIX.nc` do not change enough to 
meet the proportion threshold. `MIX6.d` is not detected at all.
* `1NN` and `2NN` do not meet the change threshold.
* `NIB.1` lacks everything. As discussed above, the gene is present in the annotation, but it was not recorded at all 
in the data, likely to the data coming from a a different version of the annotation.


### Discrepancy handling

It's been already mentioned above that it is possible that the annotation provided may not be identical to the one 
on which the data is based. `rats` bases its data munging and output on the annotation provided. 

* Any transcripts/genes present in the counts data but missing from the annotation will be ignored completely and 
will not show up in the output.
* Any transcript/gene present in the annotation but missing from the count data will automatically be padded with 
zero counts throughout and will be included in the output.
* If the samples appear to use different annotations from one another, `rats` will abort.

**You should avoid mixing annotations**, as there is no guarantee (at least for some annotations) that the transcript 
identification codes will remain consistent between annotation versions.


## Example 3: Input options

We'll still use the simulated data, as in the previous examples.

```{r}
library(rats)
library(data.table)

sim <- sim_sleuth_data(cnames = c("foo", "bar"))
```


### Comparing by different variables

So far, we've always compared conditions (`slo$sample_to_covariates[["condition"]]`). Your data could contain other 
variables as well. As we saw in a previous example, our simulated data contains one called `batch`.

```{r}
# Compare by a different variable. In this case "batch".
mydtu <- call_DTU(sim$slo, sim$annot, "ba", "bb", varname= "batch")
```


### Bootstrapping & Confidence in DTU calls

We already saw in the previous example how to activate bootstrapping of the DTU calls. It adds significant processing time, 
but **we recommend using this option**, as it provides a measure of confidence in the p-values. Current transcript quantification 
algorithms such as [kallisto](https://pachterlab.github.io/kallisto/about), [salmon](https://combine-lab.github.io/salmon/) and 
[sailfish](http://www.cs.cmu.edu/~ckingsf/software/sailfish/) use probabilistic approaches to estimate transcript abundance. 
Bootstrapping the DTU calls controls for the variability in these quantifications.


```{r eval=FALSE}
# Evaluation of this code is disabled in this vignette, to keep it timely.
# Bootstrap everything.
mydtu <- call_DTU(sim$slo, sim$annot, "foo", "bar", boots = "both", bootnum = 1000)
# Only bootstrap transcript calls.
mydtu <- call_DTU(sim$slo, sim$annot, "foo", "bar", boots = "prop-test")
# Only bootstrap gene calls.
mydtu <- call_DTU(sim$slo, sim$annot, "foo", "bar", boots = "G-test")
```

1. `boots` Although we recommend bootstrapping both gene-level and transcript-level DTU calls, dropping one would reduce 
processing time when doing a large number of bootstraps.
2. `bootnum` Generally, greater is better but it takes longer. There is also an upper limit that depends on the size of 
your annotation. This is due to R's limit on the max size of matrices. For an annotation of 40000 transcripts, you should 
be able to do 10000 iterations.



### Thresholds

Three thresholds can be set in `rats`. One is the desired significance level, the other two are used to pre-filter the data.
The main reason for pre-filtering is to reduce the magnitude of multiple testing error, by reducing the number of tests carried out.

```{r}
mydtu <- call_DTU(sim$slo, sim$annot, "foo", "bar", p_thresh = 0.01, 
                  count_thresh = 10, dprop_thresh = 0.25)
# You can view if/how this changes the result by using the commands shown in the 
# previous two examples.
```

1. `p_thresh` Significance level. P-values below this will be considered significant. 0.05 is a very permissive value.
2. `count_thresh` At least one of the two conditions needs to exceed this number of fragments per sample for the transcript 
to be considered. Low counts have high uncertainty and low significance. Removing such entries from the analysis when both 
conditions are low-count improves the confidence in the predictions of the remaining transcripts.
3. `dprop_thresh` This is a proxy for biological significance. A transcript's proportion must change by at least this much 
for it to be considered. The need for this is due to the fact that high counts will make even minute differences show up as 
statistically significant, however very small changes are likely to be biologically indifferent.

The default values for all three thresholds are rather lenient. You may want to set them higher. To quickly check the results 
of higher thresholds AFTER you've already called DTU, you don't need to rerun everything. Simply use normal table access 
operations like this:

```{r}
# P value thresholds can be adjusted upwards or downwards post-run.
new_thresh = 0.01
newgenecalls <- mydtu$Genes[, .(parent_id, Gt_pvalAB_corr < new_thresh & 
                                           Gt_pvalBA_corr < new_thresh)]
newtransccalls <- mydtu$Transcripts[, .(target_id, parent_id, Pt_pval_corr < new_thresh)]
print( newgenecalls )

# Pre-filtering criteria can be made ONLY STRICTER. To make them more lenient you must 
# re-rerun the calls. Bear in mind that post-hoc changes to the pre-filter thresholds 
# will not update the adjusted p-values.
new_dpropthresh <- 0.3
newtransccalls <- mydtu$Transcripts[(abs(Dprop) > new_dpropthresh), 
                                    .(target_id, parent_id, Pt_DTU)]
print( newtransccalls )
```


### Test selection

`rats` runs gene-level call (slower, more sensitive) and trnscript-level call (faster, less sensitive, more explicit report). 
They are complementary, but you can skip either one. The fields of the skipped test will be filled with `NA`.

```{r}
# Transcripts only.
mydtu <- call_DTU(sim$slo, sim$annot, "foo", "bar", testmode="prop-test")
# Genes only.
mydtu <- call_DTU(sim$slo, sim$annot, "foo", "bar", testmode="G-test")
```


### Multiple testing correction

Testing multiple null hypotheses increases the chance of one being falsely rejected. To keep the overall false rate at the 
desired level, the raw p-values must be adjusted. This is achieved using R's build-in `p.adjust()`. The default adjustment 
method is `BH` (Benjamini-Hoffmann). A full list of options is listed in R's `p.adjust.methods`.

```{r}
# Bonferroni correction.
mydtu <- call_DTU(sim$slo, sim$annot, "foo", "bar", correction = "bonferroni")
```

### Input structure

`rats` Needs to pull information from different fields of the sleuth object and the annotation. For flexibility you can 
change the default names of these fields.

```{r}
# Lets create some input with custom field names. The data is exactly the same as before.
sim <- sim_sleuth_data(varname="mouse", cnames=c("Splinter", "Mickey"), COUNTS_COL="the-counts", 
                       TARGET_COL="transcript", PARENT_COL="gene", BS_TARGET_COL = "trscr")
print( sim$slo$sample_to_covariates )
print( sim$slo$kal[[1]]$bootstrap[[1]] )
print( sim$annot )
```

With the fields names changed, we need to tell `rats` were to find the data:

```{r}
mydtu <- call_DTU(sim$slo, sim$annot, "Splinter", "Mickey", varname="mouse", 
                  TARGET_COL="transcript", PARENT_COL="gene", 
                  COUNTS_COL="the-counts", BS_TARGET_COL="trscr")

# The output structure will always use the same field names, regardless of 
# what the input names are.
print( names(mydtu$Transcripts) )
```


## Example 4: Visualisation of results

The dtu object's tables provide a host of information. The `rats` package also includes some basic visualisation aids.

Let's start by setting up some data.

```{r}
library(rats)

sim <- sim_sleuth_data(cnames = c("foo", "bar"))
mydtu <- call_DTU(sim$slo, sim$annot, "foo", "bar")
```


### Summary

A really simple tally of the outcome, to help get a sense of the bigger picture.

```{r}
dtu_summary(mydtu)
```


### Plot of abundance changes

A table full of numbers may be heaven to some and hell to others. This function allows you to visualise what's
going on in any particular gene.

```{r}
# The error bars for counts represent 2 standard deviations from the mean.
plot_gene(mydtu, "MIX6")
```

A variation of the above is to plot the proportions instead of the mean counts. You might also find it clearer
if a frequency polygon is used instead of the bars.

```{r}
# The error bars for proportions represent the standard error of the estimated proportions.
plot_gene(mydtu, "MIX6", vals="proportions", style="lines")
```


### Plots of overall run

This family of plots show the distribution of the calls. Our usual simulated dataset is too small to demonstrate
what these plots typically would look like, but it is adequate to demonstrate the usage. A more illustrative dataset
will be prepared and used in a future release. We are also planning to make these plots interactive.

If you remmber from earlier examples, one of the genes/transcript had `NaN` proportions due to its counts being 0.
This is removed by `ggplot2` and is responsible for the warning displayed. Nothing to worry about.

```{r}
# Proportion change VS significance. Probably the most common plot.
plot_overview(mydtu, type="dpropVsig")

# Proportion change VS gene expression.
plot_overview(mydtu, type="dpropVcount")

# Proportion VS gene expression.
plot_overview(mydtu, type="propVcount")

# Proportion VS gene expression count.
plot_overview(mydtu, type="maxdprop")
```








