---
title: "RATs Basics"
author: "Kimon Froussios"
date: "8 July 2016"
output: 
  html_document: 
    fig_caption: yes
    keep_md: yes
    theme: readable
    toc: yes
runtime: shiny
---


# Relative Abundance of Transcripts (rats): Basic usage and output explanation.

This is an R package that builds on the functionality of [sleuth](http://pachterlab.github.io/sleuth/). It is aimed at people
analyzing **gene expression** and **transcript abundance**, particularly with **RNA-Seq** type of data in mind.

It uses proportions test (based on chi square) to find which transcripts of a gene change expression relative to the other transcripts of the same gene. 
For a more sensitive approach, it also uses G test to find in which genes the transcripts change in abundance relative to one 
another, although that test is not able to tell which specific transcripts are responsible for this.

This *R Markdown* vignette addresses the **basic usage** of the package and explains what the **output** is.
For more information on the input parameters and output interpretation also check the other vignettes.


## Example 1: Using the defaults.

First, load the package (assuming it has been installed, as instructed in the README). 

```{r}
library(rats)
```


### Preparation of data

In a real usage case, the input data would be the output of [sleuth](http://pachterlab.github.io/sleuth/). For details on what that looks
like and how to use sleuth you should refer to its proper documentation.

For this example, we'll use the bundled data simulator. The data simulator was created for the purpose of testing that
the package works correctly, but the properties of the generated data make it also very suitable for explaining the behaviour of the package.


```{r}
simdat <- sim_sleuth_data(cnames = c("foo", "bar"))

# For convenience let's assign the contents of the list to separate variables.
slo <- simdat$slo       # Simulated minimal sleuth object.
annot <- simdat$annot  # Annotation for the above data.

```

The above function has a number of customisation parameters, but they are mostly relevant for testing. The `cnames` parameter defines
the names to use for the conditions. Leave everything else at their default values.

The simultion returns a list of 3 objects, only the first two of which are relevant here. The third element is used for code testing. 

1. `slo` emulates an R object you would obtain from calling **differential transcript expression (DTE)** using [sleuth](http://pachterlab.github.io/sleuth/).
The real objects are quite large and complex. The simulated one contains only the parts that are relevant to calling **differential transcript usage (DTU)**
with `rats`. The data is completely artificial and chosen so as to test/demonstrate specific scenarios. It contains a handful of made-up genes and transcripts,
and a handful of samples/replicates with a handful of bootstraps per sample. Real data will likely have many more bootstraps per sample, and *hopefully more replicates*
per conditions as well.

```{r}
# Let's have a look at the simulated data.
summary(slo)
# Names of the samples and conditions. Samples are grouped and compared based on these.
print( slo$sample_to_covariates )
```

The values under "condition" are the ones we specified when we called the simulator. There's also an additional variable, "batch", which is added by the
simulator. Your data may have more/fewer/different variables.

```{r}
# Estimated fragment counts in bootstrap 1 of sample 1.
print( slo$kal[[1]]$bootstrap[[1]] )
```

2. `annot` is an auxiliary `data.frame` required by rats. It simply matches transcript identification codes to gene 
identification codes, since DTU refers to changes in relative expression of transcripts within any single gene. **When working with your own data, you will
need to provide an appropriate such dataframe**.

```{r}
# And this is what the annotation looks like.
print(annot)
```


### Calling DTU

We have some count data and an annotation, we can now call DTU using rats.

```{r}
mydtu <- calculate_DTU(slo, annot, "foo", "bar")
```

`calculate_DTU()` takes 4 mandatory arguments: a sleuth object, an annotation dataframe matching transcripts to genes, and the names of two conditions to
compare. By default, the two names are expected to be values found in the "condition" column of the `slo$sample_to_conditions` table. You can override
this if the column is named differently in your data, or if you want to compare by a different variable. More on this in the next example, in the next vignette.

The returned structure is a list with 3 elements:

```{r}
print(summary(mydtu))
```

1. `Parameters` contains information about the run, such as threshold values and condition names.

```{r}
print(mydtu$Parameters)
```

2. `Genes` contains gene-level information. The results of the **G tests** are found here. A large number of columns are NA in this example, as they
refer to bootstrapping results, which is not carried out by default.

```{r}
print(mydtu$Genes)
```

3. `Transcripts` contains transcript-level information. The results of the **proportion tests** are found here. Several columns are `NA` in this example, as they
refer to bootstrapping results, which is not carried out by default.

```{r}
print(mydtu$Transcripts)
```


### Results

1. The `Gt_DTU` column in either of the two tables lists which **genes** have DTU. This is based on G test, which takes into account all the transcripts of the gene.
This makes it more sensitive to changes, but it also means it cannot attribute the change to specific transcripts in the gene.
2. The `Pt_DTU` column in the `Transcripts` table lists the **transcripts** that are differentially used. Because it is based on the proportion test for a single
transcript, it is less sensitive.
3. `parent_id` lists the gene IDs. `target_id` lists the transcript IDs.
4. Most other columns offer additional information to help understand the result.

In our example, genes `CC` and `MIX6` show differential transcript usage. `CC` has only two transcripts, so both change. `MIX6` has 6 transcripts. Of these, `MIX6.d` was
not detected in either condition, `MIX6.nc` shows no significant change between the conditions, and the remaining 4 show different levels of change. Two are only present in
one of the two conditions (`MIX6.c3` and `MIX6.c4`), but only one of them is called as DTU, as the other's change falss below the change threshold of 0.1. Theother two
transcripts of the gene that change are present in both conditions and show significant change.

The other genes/transcripts in our example show no (significant) change or are not detected at all. There is also a large number of `NA` fields. Many of these represent
columns that report bootstrap results, but bootstraps are not run by default, so we don't have those results in this example (check one of the next examples for this).
The remaining `NA` and `NaN` represent transcripts and genes that were not tested, either due to the number of detected transcripts being less than 2, or due to not
meeting the minimum count and/or proportion change thresholds.


## Understanding the output

`Parameters`:

```{r}
names(mydtu$Parameters)
```

1. `var_name` The variable by which samples are grouped for comparison. In this example it is "condition". We could also have chosen "batch" since that is also
recorded in `slo$sample_to_covariates`.
2. `cond_A` A value of the above variable, as recorded in `slo$sample_to_covariates`.
3. `cond_B` Also a value of the comparison variable. to be compared with `cond_A`. The order of A and B does not matter.
4. `num_replic_A` The number of samples available for the first condition (`cond_A`).
5. `num_replic_B` The number of samples available for the other condition (`ond_B`).
6. `p_thresh` The significance threshold. P-values below this are called as DTU.
7. `count_thresh` The minimum fragment count threshold. Transcripts with fewer than this counts per sample are excluded from testing.
8. `dprop_thresh` The minimum proportion change threshold. Differences smaller than this will be ignored.
9. `tests` Which statistical tests were used (out of `g.test` and `prop.test`).
10. `bootstrap` Which of the above tests was bootstrapped.
11. `bootnum` Number of bootstrap iterations.
12. `threads` Number of threads used. (not currently in use)

`Genes`:

```{r}
names(mydtu$Genes)
```

1. `parent_id` Gene identification code.
2. `known_transc` Number of transcripts for this gene found in the supplied annotation.
3. `detect_transc` Number of transcripts for which fragments were detected in at least on of the conditions.
4. `eligible` Genes with fewer than 2 detected transcripts by definition cannot exhibit DTU and are excluded.
5. `Pt_DTU` Summary of the proportion tests, carried over from the `Transcripts` table. If TRUE it means that some of its transcripts changed. 
You can refer to the `Transcripts` table to find out which.
6. `Gt_DTU` Marks differential transcript usage in this gene. The G test compares a set of counts to a set of theoretical ratios. As, instead, we 
are comparing counts to counts, we use in turn each condition as reference. `Gt_DTU` is `TRUE` when **both** partial tests are `TRUE`.
7. `Gt_dtuAB` and `Gt_dtuBA` Partial DTU call, using condition B or A as reference, respectively.
9. `Gt_pvalAB` and `Gt_pvalBA` P-value for the G test, using condition B or A as reference, respectively.
11. `Gt_pvalAB_corr` and `Gt_pvalBA_corr` Same as 9., adjusted for multiple testing. Based on these, 7. is called.
13. `Gt_boot_dtuAB` and `Gt_boot_dtuBA` Proportion of bootstraps giving a positive result, using condition B or A as reference, respectively.
15. `Gt_boot_meanAB` and `Gt_boot_meanBA` Mean of the adjusted G test p-values, across bootstraps.
17. `Gt_boot_stdevAB` and `Gt_boot_stdevBA` Standard deviation of adjusted p-values, across bootstraps.
19. `Gt_boot_minAB` and `Gt_boot_minBA` The minimum p-value encountered in the bootstraps.
21. `Gt_boot_maxAB` and `Gt_boot_maxBA` The maximum p-value encountered in the bootstraps.
23. `Gt_boot_na` The number of bootstraps in which this gene was not eligible for DTU.

`Transcripts`:

```{r}
names(mydtu$Transcripts)
```

1. `target_id` Transcript identification code.
2. `parent_id` Gene identification code.
3. `prop A` and `prop_B` Proportion of the transcript in each condition.
5. `Dprop` The difference in proportion between the two conditions.
6. `eligible` At least one condition has count above the counts threshold and the proportion changes by more than the change threshold.
7. `Gt_DTU` The result of the G test for the entire gene, carried over from the `Genes` table.
8. `Pt_DTU` Marks differential transcript usage of this transcript.
9. `Pt_pval` P value from the proportions test.
10. `Pt_pval_corr` Same as 9., adjusted for multiple testing.
11. `Pt_boot_dtu` Proportion of bootstraps giving a positive call.
12. `Pt_boot_mean` Mean of the adjusted p-values, across bootstraps.
13. `Pt_boot_stdev` Standard deviation of adjusted p-values, across bootstraps.
14. `Pt_boot_min` Minimum P-value encountered in the bootstraps.
15. `Pt_boot_max` Maximum P-value encountered in the bootstraps.
16. `Pt_boot_na` Number of bootstraps in which this transcript was not eligible for DTU.
17. `sumA` and `sumB` Sum of counts in all samples of each condition. Actually, the count from each sample is the mean of all its bootstraps.
19. `meanA` and `meanB` Mean count across samples for each condition.
21. `stdevA` and `stdevB` Standard deviation of count.
23. `totalA` and `totalB` The sum of `sumA` or `sumB` for all transcript of the gene.


## Long story short (TL;DR):

* Minimum requirements for `calculate_DTU()` are a (i) [sleuth](http://pachterlab.github.io/sleuth/)-like object, (ii) a data.frame matching 
transcript IDs to gene IDs and (iii) the names of two conditions to compare (out of those listed in the sleuth object's `sample_to_covariates` table).
* DTU calls are listed in `Genes$Gt_DTU` at the **gene** level and in `Transcripts$Pt_DTU` at the **transcript** level.
* Not all genes or transcripts can be tested (depending on thresholds and number of detected trnscripts), so a lot of `NA` will be present in the output. That is the **expected behaviour**.


